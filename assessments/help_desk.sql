-- Helpdesk

-- 8. For each customer show: Company name, contact name, number of calls where the number of calls is fewer than 5
WITH call_count AS (
    SELECT Company_ref, COUNT(Issue.Call_ref) AS nc
    FROM Caller
    LEFT JOIN Issue ON Caller.Caller_id = Issue.Caller_id
    GROUP BY Company_ref
    HAVING COUNT(Issue.Call_ref)<5
)

SELECT Customer.Company_name, Caller.first_name, Caller.last_name, call_count.nc
FROM Customer 
LEFT JOIN Caller ON (Customer.Company_ref = Caller.Company_ref) AND (Customer.Contact_id = Caller.Caller_id)
JOIN call_count ON Customer.Company_ref = call_count.Company_ref
ORDER BY nc DESC

-- Alternative solution
SELECT 
    c.Company_name,
    cl.first_name,
    cl.last_name,
    call_count.nc
FROM 
    (
        SELECT 
            cl.Company_ref,
            COUNT(i.Call_ref) AS nc
        FROM 
            Caller cl
        LEFT JOIN 
            Issue i ON cl.Caller_id = i.Caller_id
        GROUP BY 
            cl.Company_ref
        HAVING 
            COUNT(i.Call_ref) < 5
    ) call_count
JOIN 
    Customer c ON c.Company_ref = call_count.Company_ref
LEFT JOIN 
    Caller cl ON c.Company_ref = cl.Company_ref AND c.Contact_id = cl.Caller_id
ORDER BY 
    call_count.nc DESC;

-- 9. For each shift show the number of staff assigned. 
-- Beware that some roles may be NULL and that the same person might have been assigned to multiple roles (The roles are 'Manager', 'Operator', 'Engineer1', 'Engineer2').
WITH staff_count AS (
SELECT Shift_date, Shift_type, Manager AS staff
FROM Shift
UNION
SELECT Shift_date, Shift_type, Operator
FROM Shift
UNION
SELECT Shift_date, Shift_type, Engineer1
FROM Shift
UNION
SELECT Shift_date, Shift_type, Engineer2
FROM Shift
)

SELECT DATE_FORMAT(Shift_date, '%Y-%m-%d') AS Shift_date, Shift_type, COUNT(DISTINCT staff) AS cw
FROM staff_count
GROUP BY Shift_date, Shift_type
ORDER BY Shift_date, Shift_type


-- 11. Show the manager and number of calls received for each hour of the day on 2017-08-12
WITH shift_dt AS (
    SELECT 
        DATE_FORMAT(Shift.Shift_date, '%Y-%m-%d') AS date, 
        Shift.Shift_type, 
        HOUR(Shift_type.Start_time) AS start_hour, 
        HOUR(Shift_type.End_time) AS end_hour, 
        Shift.Manager
    FROM Shift
    LEFT JOIN Shift_type
    ON Shift.Shift_type = Shift_type.Shift_type
    WHERE DATE(Shift.Shift_date) = '2017-08-12'
), 
call_log AS (
    SELECT 
        DATE_FORMAT(Call_date, '%Y-%m-%d %H') AS date_hour, 
        COUNT(Call_ref) AS cc, 
        CASE 
            WHEN (HOUR(Call_date) >= 8 AND HOUR(Call_date) < 14) THEN 'Early'
            WHEN (HOUR(Call_date) >= 14 AND HOUR(Call_date) < 20) THEN 'Late'
        END AS shift_type
    FROM Issue
    GROUP BY DATE(Call_date), HOUR(Call_date)
)
SELECT 
        shift_dt.manager, e
        call_log.date_hour, 
        call_log.cc
FROM call_log
JOIN shift_dt ON DATE(call_log.date_hour) = shift_dt.date AND call_log.shift_type = shift_dt.shift_type
ORDER BY call_log.date_hour

-- 12. 80/20 rule. 
-- It is said that 80% of the calls are generated by 20% of the callers. Is this true? What percentage of calls are generated by the most active 20% of callers.

/*
Notes: 
SET was not available in sqlzoo.net; or else we could set variables like this: 
SET @total_callers = (SELECT COUNT(DISTINCT caller_id) FROM Caller); 
SET @total_calls = (SELECT COUNT(DISTINCT call_ref) FROM Issue); 

There are 3 solutions to this question. 
The first solution will count any callers within the top 20% rank, while the second solution will count the top 20% of callers with the most calls.
The 2nd solution returns the answer according to SQL ZOO and actually answer the question, but the 1st solution is more accurate for analytical purpose. 
It is because if we cut off the top 20%, there can be callers with the same number of calls as the last callers within the 20% limit, but got filtered out. 
3rd solution is to replace RANK from 1st solution w/ row_number so that we will only count the top 20% of callers with the most calls, it should return the same ressult as 2nd solution. 
*/

-- 1st solution
WITH cc AS (
    SELECT 
        caller_id, 
        COUNT(DISTINCT call_ref) as cc
    FROM Issue
    GROUP BY caller_id
), 
totals AS (
    SELECT
        (SELECT COUNT(DISTINCT caller_id) FROM Caller) AS total_callers, 
        (SELECT COUNT(DISTINCT call_ref) FROM Issue) AS total_calls
), 
caller_rank AS (
    SELECT 
        caller_id, 
        cc, 
        RANK() OVER (ORDER BY cc DESC) AS rank
    FROM cc)
SELECT SUM(cc)/(SELECT total_calls FROM totals) AS t20pc
FROM caller_rank
WHERE rank <= (SELECT total_callers FROM totals) *0.2

-- 2nd solution
SELECT ROUND(SUM(p2.cc / (SELECT COUNT(*) FROM Issue)) * 100, 4) top_20_pc
FROM (
  SELECT p1.*, @counter := @counter + 1 counter
  FROM (SELECT @counter := 0) initvar,
       (SELECT Caller_id, COUNT(*) AS cc
        FROM Issue
        GROUP BY Caller_id
	ORDER BY COUNT(*) DESC) AS p1
     ) AS p2
WHERE counter <= (.2 * @counter);

-- 3rd solution
WITH cc AS (
    SELECT 
        caller_id, 
        COUNT(DISTINCT call_ref) as cc
    FROM Issue
    GROUP BY caller_id
), 
totals AS (
    SELECT
        (SELECT COUNT(DISTINCT caller_id) FROM Caller) AS total_callers, 
        (SELECT COUNT(DISTINCT call_ref) FROM Issue) AS total_calls
), 
caller_rank AS (
    SELECT 
        caller_id, 
        cc, 
        ROW_NUMBER() OVER (ORDER BY cc DESC) AS rank
    FROM cc)
SELECT SUM(cc)/(SELECT total_calls FROM totals) AS t20pc
FROM caller_rank
WHERE rank <= (SELECT total_callers FROM totals) *0.2

-- 13. Annoying customers. 
-- Customers who call in the last five minutes of a shift are annoying. Find the most active customer who has never been annoying.
WITH 
day_shift_cutoff AS (
    SELECT 
        shift_type, 
        SUBTIME(End_time, '00:05') AS cutoff, 
        end_time
    FROM Shift_type
    WHERE shift_type = 'Early'
), 
night_shift_cutoff AS (
    SELECT 
        shift_type, 
        SUBTIME(End_time, '00:05') AS cutoff, 
        end_time
    FROM Shift_type
    WHERE shift_type = 'Late'
), 
-- use this cte to filter out any annoying customers, so as long as they have annoying calls, they won't be included in the count in the later query
annoying_cust AS (
    SELECT 
        DISTINCT Caller.Company_ref
    FROM Issue
    LEFT JOIN Caller ON Issue.Caller_id = Caller.Caller_id
    WHERE 
        TIME(call_date) BETWEEN (SELECT cutoff FROM day_shift_cutoff) AND (SELECT end_time FROM day_shift_cutoff)
        OR
        TIME(call_date) BETWEEN (SELECT cutoff FROM night_shift_cutoff) AND (SELECT end_time FROM night_shift_cutoff)
)
SELECT 
    Customer.Company_name, 
    COUNT(Issue.Call_ref) AS abna
FROM Issue
LEFT JOIN Caller ON Issue.Caller_id = Caller.Caller_id
LEFT JOIN Customer ON Caller.Company_ref = Customer.Company_ref
WHERE Customer.Company_ref NOT IN (SELECT Company_ref FROM annoying_cust)
GROUP BY Customer.Company_name
ORDER BY abna DESC
LIMIT 1

-- 14. Maximal usage
-- If every caller registered with a customer makes at least one call in one day then that customer has "maximal usage" of the service. 
-- List the maximal customers for 2017-08-13.

WITH 
ic AS (
    SELECT Caller.Company_ref, COUNT(DISTINCT Issue.Caller_id) AS caller_count
    FROM Issue
    LEFT JOIN Caller ON Issue.Caller_id = Caller.Caller_id
    WHERE DATE(Issue.Call_date) = '2017-08-13'
    GROUP BY Caller.Company_ref
), 
cc AS (
    SELECT Company_ref, COUNT(DISTINCT Caller_id) AS registered_callers
    FROM Caller
    GROUP BY Company_ref
)
SELECT Customer.Company_name, ic.caller_count, cc.registered_callers
FROM ic 
LEFT JOIN cc ON ic.Company_ref = cc.Company_ref
LEFT JOIN Customer ON ic.Company_ref = Customer.Company_ref
WHERE ic.caller_count = cc.registered_callers -- this is the crucial line: compare number of callers from the issue table with the number of callers from the caller table
-- if they are not equal, it would means we have registered callers that didn't make any calls, so the customer won't have maximal usage. 
-- the where clause fitlers out any customers that don't have maximal usage
ORDER BY Customer.Company_name

-- 15. Consecutive calls occur when an operator deals with two callers within 10 minutes. 
-- Find the longest sequence of consecutive calls â€“ give the name of the operator and the first and last call date in the sequence.

-- this is a practice for gaps and islands problem, but not the correct solution for the question, as this doesn't identify the start of the sequence. 
WITH calls AS (
    SELECT 
        taken_by, 
        Call_date, 
        LAG(Call_date, 1) OVER(PARTITION BY taken_by ORDER BY Call_date) AS previous_call, 
        LEAD(Call_date, 1) OVER(PARTITION BY taken_by ORDER BY Call_date) AS next_call
    FROM Issue
    WHERE taken_by = 'AB1'
), 
continious_calls AS (
    SELECT 
        taken_by, 
        call_date, 
        previous_call, 
        TIMESTAMPDIFF(MINUTE, previous_call, call_date) AS prev_call_diff, 
        TIMESTAMPDIFF(MINUTE, call_date, next_call) AS next_call_diff, 
        CASE WHEN (
            previous_call IS NULL 
            OR TIMESTAMPDIFF(MINUTE, previous_call, call_date) <= 10
            )
        THEN 1 ELSE 0 END AS continious_calls
    FROM calls
)
call_sequence AS (
    SELECT 
        *, 
        ROW_NUMBER() OVER(PARTITION BY taken_by ORDER BY call_date) AS seq, -- sequence number for each call
        ROW_NUMBER() OVER(PARTITION BY taken_by, continious_calls ORDER BY call_date) AS seq_by_cont_calls -- sequence number by continious calls flag
    FROM continious_calls
), 
seq_id AS (
    SELECT 
        *, 
        seq - seq_by_cont_calls AS seq_id -- this will give us the same sequence number for each continious calls (doesn't acccount for the start of the sequence)
    FROM call_sequence
    ORDER BY taken_by, call_date, previous_call
) 
SELECT 
    taken_by, 
    COUNT(*) AS call_count
FROM seq_id
GROUP BY taken_by, seq_id

-- correct solution
WITH calls AS (
    SELECT 
        taken_by, 
        Call_date, 
        LAG(Call_date, 1) OVER(PARTITION BY taken_by ORDER BY Call_date) AS previous_call
    FROM Issue
), 
min_diff AS (
    SELECT 
        taken_by, 
        call_date, 
        previous_call, 
        TIMESTAMPDIFF(MINUTE, previous_call, call_date) AS prev_call_diff
    FROM calls
), 
-- identify the start of the cluster, everytime the clsuter start, it will be 1, otherwise 0. 
-- then it will sum the value from all previous rows to get the cluster id.
-- when the sequence is:            1, 0, 0, 0, 1, 0, 0
-- the summed cluster id will be:   1, 1, 1, 1, 2, 2, 2
cluster_id AS (
    SELECT
    *,
    SUM(
        CASE 
        WHEN prev_call_diff > 10 OR prev_call_diff IS NULL THEN 1 
        ELSE 0 
        END
    ) OVER (PARTITION BY taken_by ORDER BY call_date ROWS UNBOUNDED PRECEDING) AS cluster_id
    FROM min_diff
)
SELECT
    taken_by, 
    MIN(call_date) AS first_call, 
    MAX(call_date) AS last_call,
    COUNT(*) AS call_count
FROM cluster_id
GROUP BY taken_by, cluster_id
ORDER BY call_count DESC
LIMIT 1